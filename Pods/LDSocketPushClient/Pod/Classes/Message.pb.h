// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_Message_2eproto__INCLUDED
#define PROTOBUF_Message_2eproto__INCLUDED

#include <string>

#include "common.h"

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include "generated_message_util.h"
#include "message.h"
#include "repeated_field.h"
#include "extension_set.h"
#include "generated_enum_reflection.h"
#include "unknown_field_set.h"
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Message_2eproto();
void protobuf_AssignDesc_Message_2eproto();
void protobuf_ShutdownFile_Message_2eproto();

class HeartBeat;
class Publish;
class AuthBackend;
class RegDev;
class Subscribe;
class RetMsg;
class Response;

enum SubType {
  SUB = 1,
  UNSUB = 2
};
bool SubType_IsValid(int value);
const SubType SubType_MIN = SUB;
const SubType SubType_MAX = UNSUB;
const int SubType_ARRAYSIZE = SubType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubType_descriptor();
inline const ::std::string& SubType_Name(SubType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubType_descriptor(), value);
}
inline bool SubType_Parse(
    const ::std::string& name, SubType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubType>(
    SubType_descriptor(), name, value);
}
enum DevType {
  IOS = 1,
  ANDROID = 2,
  WP = 3
};
bool DevType_IsValid(int value);
const DevType DevType_MIN = IOS;
const DevType DevType_MAX = WP;
const int DevType_ARRAYSIZE = DevType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DevType_descriptor();
inline const ::std::string& DevType_Name(DevType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DevType_descriptor(), value);
}
inline bool DevType_Parse(
    const ::std::string& name, DevType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DevType>(
    DevType_descriptor(), name, value);
}
enum PushType {
  GROUP = 1,
  SPECIAL = 2,
  MULTI = 3
};
bool PushType_IsValid(int value);
const PushType PushType_MIN = GROUP;
const PushType PushType_MAX = MULTI;
const int PushType_ARRAYSIZE = PushType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PushType_descriptor();
inline const ::std::string& PushType_Name(PushType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PushType_descriptor(), value);
}
inline bool PushType_Parse(
    const ::std::string& name, PushType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PushType>(
    PushType_descriptor(), name, value);
}
enum RetCode {
  SUCCESS = 1,
  FAIL = 2,
  CACHED = 3
};
bool RetCode_IsValid(int value);
const RetCode RetCode_MIN = SUCCESS;
const RetCode RetCode_MAX = CACHED;
const int RetCode_ARRAYSIZE = RetCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* RetCode_descriptor();
inline const ::std::string& RetCode_Name(RetCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    RetCode_descriptor(), value);
}
inline bool RetCode_Parse(
    const ::std::string& name, RetCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RetCode>(
    RetCode_descriptor(), name, value);
}
// ===================================================================

class HeartBeat : public ::google::protobuf::Message {
 public:
  HeartBeat();
  virtual ~HeartBeat();

  HeartBeat(const HeartBeat& from);

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeat& default_instance();

  void Swap(HeartBeat* other);

  // implements Message ----------------------------------------------

  HeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeat& from);
  void MergeFrom(const HeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.HeartBeat)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static HeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class Publish : public ::google::protobuf::Message {
 public:
  Publish();
  virtual ~Publish();

  Publish(const Publish& from);

  inline Publish& operator=(const Publish& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Publish& default_instance();

  void Swap(Publish* other);

  // implements Message ----------------------------------------------

  Publish* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Publish& from);
  void MergeFrom(const Publish& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // required int32 productCode = 2;
  inline bool has_productcode() const;
  inline void clear_productcode();
  static const int kProductCodeFieldNumber = 2;
  inline ::google::protobuf::int32 productcode() const;
  inline void set_productcode(::google::protobuf::int32 value);

  // required string topic = 3;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 3;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional bytes body = 4;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 4;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const void* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // optional .message.PushType pushType = 5 [default = GROUP];
  inline bool has_pushtype() const;
  inline void clear_pushtype();
  static const int kPushTypeFieldNumber = 5;
  inline ::message::PushType pushtype() const;
  inline void set_pushtype(::message::PushType value);

  // optional string deviceId = 6;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 6;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional string accountId = 7;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIdFieldNumber = 7;
  inline const ::std::string& accountid() const;
  inline void set_accountid(const ::std::string& value);
  inline void set_accountid(const char* value);
  inline void set_accountid(const char* value, size_t size);
  inline ::std::string* mutable_accountid();
  inline ::std::string* release_accountid();
  inline void set_allocated_accountid(::std::string* accountid);

  // optional int64 expiry = 8 [default = 0];
  inline bool has_expiry() const;
  inline void clear_expiry();
  static const int kExpiryFieldNumber = 8;
  inline ::google::protobuf::int64 expiry() const;
  inline void set_expiry(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:message.Publish)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_productcode();
  inline void clear_has_productcode();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_pushtype();
  inline void clear_has_pushtype();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_expiry();
  inline void clear_has_expiry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 productcode_;
  ::std::string* topic_;
  ::std::string* body_;
  ::std::string* deviceid_;
  ::std::string* accountid_;
  ::google::protobuf::int64 expiry_;
  int pushtype_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static Publish* default_instance_;
};
// -------------------------------------------------------------------

class AuthBackend : public ::google::protobuf::Message {
 public:
  AuthBackend();
  virtual ~AuthBackend();

  AuthBackend(const AuthBackend& from);

  inline AuthBackend& operator=(const AuthBackend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthBackend& default_instance();

  void Swap(AuthBackend* other);

  // implements Message ----------------------------------------------

  AuthBackend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthBackend& from);
  void MergeFrom(const AuthBackend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // required int32 productCode = 2;
  inline bool has_productcode() const;
  inline void clear_productcode();
  static const int kProductCodeFieldNumber = 2;
  inline ::google::protobuf::int32 productcode() const;
  inline void set_productcode(::google::protobuf::int32 value);

  // required string authToken = 3;
  inline bool has_authtoken() const;
  inline void clear_authtoken();
  static const int kAuthTokenFieldNumber = 3;
  inline const ::std::string& authtoken() const;
  inline void set_authtoken(const ::std::string& value);
  inline void set_authtoken(const char* value);
  inline void set_authtoken(const char* value, size_t size);
  inline ::std::string* mutable_authtoken();
  inline ::std::string* release_authtoken();
  inline void set_allocated_authtoken(::std::string* authtoken);

  // @@protoc_insertion_point(class_scope:message.AuthBackend)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_productcode();
  inline void clear_has_productcode();
  inline void set_has_authtoken();
  inline void clear_has_authtoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 productcode_;
  ::std::string* authtoken_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static AuthBackend* default_instance_;
};
// -------------------------------------------------------------------

class RegDev : public ::google::protobuf::Message {
 public:
  RegDev();
  virtual ~RegDev();

  RegDev(const RegDev& from);

  inline RegDev& operator=(const RegDev& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegDev& default_instance();

  void Swap(RegDev* other);

  // implements Message ----------------------------------------------

  RegDev* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegDev& from);
  void MergeFrom(const RegDev& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // required int32 productCode = 2;
  inline bool has_productcode() const;
  inline void clear_productcode();
  static const int kProductCodeFieldNumber = 2;
  inline ::google::protobuf::int32 productcode() const;
  inline void set_productcode(::google::protobuf::int32 value);

  // required string deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // required .message.DevType devType = 4;
  inline bool has_devtype() const;
  inline void clear_devtype();
  static const int kDevTypeFieldNumber = 4;
  inline ::message::DevType devtype() const;
  inline void set_devtype(::message::DevType value);

  // optional string token = 5;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 5;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:message.RegDev)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_productcode();
  inline void clear_has_productcode();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_devtype();
  inline void clear_has_devtype();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 productcode_;
  ::std::string* deviceid_;
  ::std::string* token_;
  int devtype_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RegDev* default_instance_;
};
// -------------------------------------------------------------------

class Subscribe : public ::google::protobuf::Message {
 public:
  Subscribe();
  virtual ~Subscribe();

  Subscribe(const Subscribe& from);

  inline Subscribe& operator=(const Subscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Subscribe& default_instance();

  void Swap(Subscribe* other);

  // implements Message ----------------------------------------------

  Subscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Subscribe& from);
  void MergeFrom(const Subscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // required string topic = 2;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 2;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // required .message.SubType subType = 3;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubTypeFieldNumber = 3;
  inline ::message::SubType subtype() const;
  inline void set_subtype(::message::SubType value);

  // optional .message.PushType pushType = 6 [default = GROUP];
  inline bool has_pushtype() const;
  inline void clear_pushtype();
  static const int kPushTypeFieldNumber = 6;
  inline ::message::PushType pushtype() const;
  inline void set_pushtype(::message::PushType value);

  // optional string accountId = 4;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIdFieldNumber = 4;
  inline const ::std::string& accountid() const;
  inline void set_accountid(const ::std::string& value);
  inline void set_accountid(const char* value);
  inline void set_accountid(const char* value, size_t size);
  inline ::std::string* mutable_accountid();
  inline ::std::string* release_accountid();
  inline void set_allocated_accountid(::std::string* accountid);

  // @@protoc_insertion_point(class_scope:message.Subscribe)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_subtype();
  inline void clear_has_subtype();
  inline void set_has_pushtype();
  inline void clear_has_pushtype();
  inline void set_has_accountid();
  inline void clear_has_accountid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* topic_;
  ::google::protobuf::int32 requestid_;
  int subtype_;
  ::std::string* accountid_;
  int pushtype_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static Subscribe* default_instance_;
};
// -------------------------------------------------------------------

class RetMsg : public ::google::protobuf::Message {
 public:
  RetMsg();
  virtual ~RetMsg();

  RetMsg(const RetMsg& from);

  inline RetMsg& operator=(const RetMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetMsg& default_instance();

  void Swap(RetMsg* other);

  // implements Message ----------------------------------------------

  RetMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetMsg& from);
  void MergeFrom(const RetMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes body = 1;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 1;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const void* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // optional string topic = 2;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 2;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional .message.PushType pushType = 3 [default = GROUP];
  inline bool has_pushtype() const;
  inline void clear_pushtype();
  static const int kPushTypeFieldNumber = 3;
  inline ::message::PushType pushtype() const;
  inline void set_pushtype(::message::PushType value);

  // @@protoc_insertion_point(class_scope:message.RetMsg)
 private:
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_pushtype();
  inline void clear_has_pushtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* body_;
  ::std::string* topic_;
  int pushtype_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static RetMsg* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // required .message.RetCode retCode = 2;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetCodeFieldNumber = 2;
  inline ::message::RetCode retcode() const;
  inline void set_retcode(::message::RetCode value);

  // optional string rightHost = 3;
  inline bool has_righthost() const;
  inline void clear_righthost();
  static const int kRightHostFieldNumber = 3;
  inline const ::std::string& righthost() const;
  inline void set_righthost(const ::std::string& value);
  inline void set_righthost(const char* value);
  inline void set_righthost(const char* value, size_t size);
  inline ::std::string* mutable_righthost();
  inline ::std::string* release_righthost();
  inline void set_allocated_righthost(::std::string* righthost);

  // @@protoc_insertion_point(class_scope:message.Response)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_righthost();
  inline void clear_has_righthost();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  int retcode_;
  ::std::string* righthost_;
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

// HeartBeat

// required int32 requestId = 1;
inline bool HeartBeat::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartBeat::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartBeat::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartBeat::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HeartBeat::requestid() const {
  // @@protoc_insertion_point(field_get:message.HeartBeat.requestId)
  return requestid_;
}
inline void HeartBeat::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:message.HeartBeat.requestId)
}

// -------------------------------------------------------------------

// Publish

// required int32 requestId = 1;
inline bool Publish::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Publish::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Publish::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Publish::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 Publish::requestid() const {
  // @@protoc_insertion_point(field_get:message.Publish.requestId)
  return requestid_;
}
inline void Publish::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:message.Publish.requestId)
}

// required int32 productCode = 2;
inline bool Publish::has_productcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Publish::set_has_productcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Publish::clear_has_productcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Publish::clear_productcode() {
  productcode_ = 0;
  clear_has_productcode();
}
inline ::google::protobuf::int32 Publish::productcode() const {
  // @@protoc_insertion_point(field_get:message.Publish.productCode)
  return productcode_;
}
inline void Publish::set_productcode(::google::protobuf::int32 value) {
  set_has_productcode();
  productcode_ = value;
  // @@protoc_insertion_point(field_set:message.Publish.productCode)
}

// required string topic = 3;
inline bool Publish::has_topic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Publish::set_has_topic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Publish::clear_has_topic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Publish::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& Publish::topic() const {
  // @@protoc_insertion_point(field_get:message.Publish.topic)
  return *topic_;
}
inline void Publish::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:message.Publish.topic)
}
inline void Publish::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.Publish.topic)
}
inline void Publish::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.Publish.topic)
}
inline ::std::string* Publish::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.Publish.topic)
  return topic_;
}
inline ::std::string* Publish::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Publish::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.Publish.topic)
}

// optional bytes body = 4;
inline bool Publish::has_body() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Publish::set_has_body() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Publish::clear_has_body() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Publish::clear_body() {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& Publish::body() const {
  // @@protoc_insertion_point(field_get:message.Publish.body)
  return *body_;
}
inline void Publish::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set:message.Publish.body)
}
inline void Publish::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.Publish.body)
}
inline void Publish::set_body(const void* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.Publish.body)
}
inline ::std::string* Publish::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.Publish.body)
  return body_;
}
inline ::std::string* Publish::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Publish::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.Publish.body)
}

// optional .message.PushType pushType = 5 [default = GROUP];
inline bool Publish::has_pushtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Publish::set_has_pushtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Publish::clear_has_pushtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Publish::clear_pushtype() {
  pushtype_ = 1;
  clear_has_pushtype();
}
inline ::message::PushType Publish::pushtype() const {
  // @@protoc_insertion_point(field_get:message.Publish.pushType)
  return static_cast< ::message::PushType >(pushtype_);
}
inline void Publish::set_pushtype(::message::PushType value) {
  assert(::message::PushType_IsValid(value));
  set_has_pushtype();
  pushtype_ = value;
  // @@protoc_insertion_point(field_set:message.Publish.pushType)
}

// optional string deviceId = 6;
inline bool Publish::has_deviceid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Publish::set_has_deviceid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Publish::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Publish::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& Publish::deviceid() const {
  // @@protoc_insertion_point(field_get:message.Publish.deviceId)
  return *deviceid_;
}
inline void Publish::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set:message.Publish.deviceId)
}
inline void Publish::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.Publish.deviceId)
}
inline void Publish::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.Publish.deviceId)
}
inline ::std::string* Publish::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.Publish.deviceId)
  return deviceid_;
}
inline ::std::string* Publish::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Publish::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.Publish.deviceId)
}

// optional string accountId = 7;
inline bool Publish::has_accountid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Publish::set_has_accountid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Publish::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Publish::clear_accountid() {
  if (accountid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_->clear();
  }
  clear_has_accountid();
}
inline const ::std::string& Publish::accountid() const {
  // @@protoc_insertion_point(field_get:message.Publish.accountId)
  return *accountid_;
}
inline void Publish::set_accountid(const ::std::string& value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
  // @@protoc_insertion_point(field_set:message.Publish.accountId)
}
inline void Publish::set_accountid(const char* value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.Publish.accountId)
}
inline void Publish::set_accountid(const char* value, size_t size) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.Publish.accountId)
}
inline ::std::string* Publish::mutable_accountid() {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.Publish.accountId)
  return accountid_;
}
inline ::std::string* Publish::release_accountid() {
  clear_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = accountid_;
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Publish::set_allocated_accountid(::std::string* accountid) {
  if (accountid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete accountid_;
  }
  if (accountid) {
    set_has_accountid();
    accountid_ = accountid;
  } else {
    clear_has_accountid();
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.Publish.accountId)
}

// optional int64 expiry = 8 [default = 0];
inline bool Publish::has_expiry() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Publish::set_has_expiry() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Publish::clear_has_expiry() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Publish::clear_expiry() {
  expiry_ = GOOGLE_LONGLONG(0);
  clear_has_expiry();
}
inline ::google::protobuf::int64 Publish::expiry() const {
  // @@protoc_insertion_point(field_get:message.Publish.expiry)
  return expiry_;
}
inline void Publish::set_expiry(::google::protobuf::int64 value) {
  set_has_expiry();
  expiry_ = value;
  // @@protoc_insertion_point(field_set:message.Publish.expiry)
}

// -------------------------------------------------------------------

// AuthBackend

// required int32 requestId = 1;
inline bool AuthBackend::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthBackend::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthBackend::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthBackend::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 AuthBackend::requestid() const {
  // @@protoc_insertion_point(field_get:message.AuthBackend.requestId)
  return requestid_;
}
inline void AuthBackend::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:message.AuthBackend.requestId)
}

// required int32 productCode = 2;
inline bool AuthBackend::has_productcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthBackend::set_has_productcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthBackend::clear_has_productcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthBackend::clear_productcode() {
  productcode_ = 0;
  clear_has_productcode();
}
inline ::google::protobuf::int32 AuthBackend::productcode() const {
  // @@protoc_insertion_point(field_get:message.AuthBackend.productCode)
  return productcode_;
}
inline void AuthBackend::set_productcode(::google::protobuf::int32 value) {
  set_has_productcode();
  productcode_ = value;
  // @@protoc_insertion_point(field_set:message.AuthBackend.productCode)
}

// required string authToken = 3;
inline bool AuthBackend::has_authtoken() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthBackend::set_has_authtoken() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthBackend::clear_has_authtoken() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthBackend::clear_authtoken() {
  if (authtoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authtoken_->clear();
  }
  clear_has_authtoken();
}
inline const ::std::string& AuthBackend::authtoken() const {
  // @@protoc_insertion_point(field_get:message.AuthBackend.authToken)
  return *authtoken_;
}
inline void AuthBackend::set_authtoken(const ::std::string& value) {
  set_has_authtoken();
  if (authtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authtoken_ = new ::std::string;
  }
  authtoken_->assign(value);
  // @@protoc_insertion_point(field_set:message.AuthBackend.authToken)
}
inline void AuthBackend::set_authtoken(const char* value) {
  set_has_authtoken();
  if (authtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authtoken_ = new ::std::string;
  }
  authtoken_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.AuthBackend.authToken)
}
inline void AuthBackend::set_authtoken(const char* value, size_t size) {
  set_has_authtoken();
  if (authtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authtoken_ = new ::std::string;
  }
  authtoken_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.AuthBackend.authToken)
}
inline ::std::string* AuthBackend::mutable_authtoken() {
  set_has_authtoken();
  if (authtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authtoken_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.AuthBackend.authToken)
  return authtoken_;
}
inline ::std::string* AuthBackend::release_authtoken() {
  clear_has_authtoken();
  if (authtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = authtoken_;
    authtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthBackend::set_allocated_authtoken(::std::string* authtoken) {
  if (authtoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete authtoken_;
  }
  if (authtoken) {
    set_has_authtoken();
    authtoken_ = authtoken;
  } else {
    clear_has_authtoken();
    authtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.AuthBackend.authToken)
}

// -------------------------------------------------------------------

// RegDev

// required int32 requestId = 1;
inline bool RegDev::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegDev::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegDev::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegDev::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 RegDev::requestid() const {
  // @@protoc_insertion_point(field_get:message.RegDev.requestId)
  return requestid_;
}
inline void RegDev::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:message.RegDev.requestId)
}

// required int32 productCode = 2;
inline bool RegDev::has_productcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegDev::set_has_productcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegDev::clear_has_productcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegDev::clear_productcode() {
  productcode_ = 0;
  clear_has_productcode();
}
inline ::google::protobuf::int32 RegDev::productcode() const {
  // @@protoc_insertion_point(field_get:message.RegDev.productCode)
  return productcode_;
}
inline void RegDev::set_productcode(::google::protobuf::int32 value) {
  set_has_productcode();
  productcode_ = value;
  // @@protoc_insertion_point(field_set:message.RegDev.productCode)
}

// required string deviceId = 3;
inline bool RegDev::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegDev::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegDev::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegDev::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& RegDev::deviceid() const {
  // @@protoc_insertion_point(field_get:message.RegDev.deviceId)
  return *deviceid_;
}
inline void RegDev::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set:message.RegDev.deviceId)
}
inline void RegDev::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.RegDev.deviceId)
}
inline void RegDev::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.RegDev.deviceId)
}
inline ::std::string* RegDev::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.RegDev.deviceId)
  return deviceid_;
}
inline ::std::string* RegDev::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegDev::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.RegDev.deviceId)
}

// required .message.DevType devType = 4;
inline bool RegDev::has_devtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegDev::set_has_devtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegDev::clear_has_devtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegDev::clear_devtype() {
  devtype_ = 1;
  clear_has_devtype();
}
inline ::message::DevType RegDev::devtype() const {
  // @@protoc_insertion_point(field_get:message.RegDev.devType)
  return static_cast< ::message::DevType >(devtype_);
}
inline void RegDev::set_devtype(::message::DevType value) {
  assert(::message::DevType_IsValid(value));
  set_has_devtype();
  devtype_ = value;
  // @@protoc_insertion_point(field_set:message.RegDev.devType)
}

// optional string token = 5;
inline bool RegDev::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegDev::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegDev::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegDev::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& RegDev::token() const {
  // @@protoc_insertion_point(field_get:message.RegDev.token)
  return *token_;
}
inline void RegDev::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:message.RegDev.token)
}
inline void RegDev::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.RegDev.token)
}
inline void RegDev::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.RegDev.token)
}
inline ::std::string* RegDev::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.RegDev.token)
  return token_;
}
inline ::std::string* RegDev::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegDev::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.RegDev.token)
}

// -------------------------------------------------------------------

// Subscribe

// required int32 requestId = 1;
inline bool Subscribe::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Subscribe::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Subscribe::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Subscribe::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 Subscribe::requestid() const {
  // @@protoc_insertion_point(field_get:message.Subscribe.requestId)
  return requestid_;
}
inline void Subscribe::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:message.Subscribe.requestId)
}

// required string topic = 2;
inline bool Subscribe::has_topic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Subscribe::set_has_topic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Subscribe::clear_has_topic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Subscribe::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& Subscribe::topic() const {
  // @@protoc_insertion_point(field_get:message.Subscribe.topic)
  return *topic_;
}
inline void Subscribe::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:message.Subscribe.topic)
}
inline void Subscribe::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.Subscribe.topic)
}
inline void Subscribe::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.Subscribe.topic)
}
inline ::std::string* Subscribe::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.Subscribe.topic)
  return topic_;
}
inline ::std::string* Subscribe::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Subscribe::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.Subscribe.topic)
}

// required .message.SubType subType = 3;
inline bool Subscribe::has_subtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Subscribe::set_has_subtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Subscribe::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Subscribe::clear_subtype() {
  subtype_ = 1;
  clear_has_subtype();
}
inline ::message::SubType Subscribe::subtype() const {
  // @@protoc_insertion_point(field_get:message.Subscribe.subType)
  return static_cast< ::message::SubType >(subtype_);
}
inline void Subscribe::set_subtype(::message::SubType value) {
  assert(::message::SubType_IsValid(value));
  set_has_subtype();
  subtype_ = value;
  // @@protoc_insertion_point(field_set:message.Subscribe.subType)
}

// optional .message.PushType pushType = 6 [default = GROUP];
inline bool Subscribe::has_pushtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Subscribe::set_has_pushtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Subscribe::clear_has_pushtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Subscribe::clear_pushtype() {
  pushtype_ = 1;
  clear_has_pushtype();
}
inline ::message::PushType Subscribe::pushtype() const {
  // @@protoc_insertion_point(field_get:message.Subscribe.pushType)
  return static_cast< ::message::PushType >(pushtype_);
}
inline void Subscribe::set_pushtype(::message::PushType value) {
  assert(::message::PushType_IsValid(value));
  set_has_pushtype();
  pushtype_ = value;
  // @@protoc_insertion_point(field_set:message.Subscribe.pushType)
}

// optional string accountId = 4;
inline bool Subscribe::has_accountid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Subscribe::set_has_accountid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Subscribe::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Subscribe::clear_accountid() {
  if (accountid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_->clear();
  }
  clear_has_accountid();
}
inline const ::std::string& Subscribe::accountid() const {
  // @@protoc_insertion_point(field_get:message.Subscribe.accountId)
  return *accountid_;
}
inline void Subscribe::set_accountid(const ::std::string& value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
  // @@protoc_insertion_point(field_set:message.Subscribe.accountId)
}
inline void Subscribe::set_accountid(const char* value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.Subscribe.accountId)
}
inline void Subscribe::set_accountid(const char* value, size_t size) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.Subscribe.accountId)
}
inline ::std::string* Subscribe::mutable_accountid() {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.Subscribe.accountId)
  return accountid_;
}
inline ::std::string* Subscribe::release_accountid() {
  clear_has_accountid();
  if (accountid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = accountid_;
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Subscribe::set_allocated_accountid(::std::string* accountid) {
  if (accountid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete accountid_;
  }
  if (accountid) {
    set_has_accountid();
    accountid_ = accountid;
  } else {
    clear_has_accountid();
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.Subscribe.accountId)
}

// -------------------------------------------------------------------

// RetMsg

// required bytes body = 1;
inline bool RetMsg::has_body() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetMsg::set_has_body() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetMsg::clear_has_body() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetMsg::clear_body() {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& RetMsg::body() const {
  // @@protoc_insertion_point(field_get:message.RetMsg.body)
  return *body_;
}
inline void RetMsg::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set:message.RetMsg.body)
}
inline void RetMsg::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.RetMsg.body)
}
inline void RetMsg::set_body(const void* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.RetMsg.body)
}
inline ::std::string* RetMsg::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.RetMsg.body)
  return body_;
}
inline ::std::string* RetMsg::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetMsg::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.RetMsg.body)
}

// optional string topic = 2;
inline bool RetMsg::has_topic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetMsg::set_has_topic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetMsg::clear_has_topic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetMsg::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& RetMsg::topic() const {
  // @@protoc_insertion_point(field_get:message.RetMsg.topic)
  return *topic_;
}
inline void RetMsg::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:message.RetMsg.topic)
}
inline void RetMsg::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.RetMsg.topic)
}
inline void RetMsg::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.RetMsg.topic)
}
inline ::std::string* RetMsg::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.RetMsg.topic)
  return topic_;
}
inline ::std::string* RetMsg::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RetMsg::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.RetMsg.topic)
}

// optional .message.PushType pushType = 3 [default = GROUP];
inline bool RetMsg::has_pushtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetMsg::set_has_pushtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetMsg::clear_has_pushtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetMsg::clear_pushtype() {
  pushtype_ = 1;
  clear_has_pushtype();
}
inline ::message::PushType RetMsg::pushtype() const {
  // @@protoc_insertion_point(field_get:message.RetMsg.pushType)
  return static_cast< ::message::PushType >(pushtype_);
}
inline void RetMsg::set_pushtype(::message::PushType value) {
  assert(::message::PushType_IsValid(value));
  set_has_pushtype();
  pushtype_ = value;
  // @@protoc_insertion_point(field_set:message.RetMsg.pushType)
}

// -------------------------------------------------------------------

// Response

// required int32 requestId = 1;
inline bool Response::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 Response::requestid() const {
  // @@protoc_insertion_point(field_get:message.Response.requestId)
  return requestid_;
}
inline void Response::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:message.Response.requestId)
}

// required .message.RetCode retCode = 2;
inline bool Response::has_retcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_retcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_retcode() {
  retcode_ = 1;
  clear_has_retcode();
}
inline ::message::RetCode Response::retcode() const {
  // @@protoc_insertion_point(field_get:message.Response.retCode)
  return static_cast< ::message::RetCode >(retcode_);
}
inline void Response::set_retcode(::message::RetCode value) {
  assert(::message::RetCode_IsValid(value));
  set_has_retcode();
  retcode_ = value;
  // @@protoc_insertion_point(field_set:message.Response.retCode)
}

// optional string rightHost = 3;
inline bool Response::has_righthost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_righthost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_righthost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_righthost() {
  if (righthost_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    righthost_->clear();
  }
  clear_has_righthost();
}
inline const ::std::string& Response::righthost() const {
  // @@protoc_insertion_point(field_get:message.Response.rightHost)
  return *righthost_;
}
inline void Response::set_righthost(const ::std::string& value) {
  set_has_righthost();
  if (righthost_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    righthost_ = new ::std::string;
  }
  righthost_->assign(value);
  // @@protoc_insertion_point(field_set:message.Response.rightHost)
}
inline void Response::set_righthost(const char* value) {
  set_has_righthost();
  if (righthost_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    righthost_ = new ::std::string;
  }
  righthost_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.Response.rightHost)
}
inline void Response::set_righthost(const char* value, size_t size) {
  set_has_righthost();
  if (righthost_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    righthost_ = new ::std::string;
  }
  righthost_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.Response.rightHost)
}
inline ::std::string* Response::mutable_righthost() {
  set_has_righthost();
  if (righthost_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    righthost_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.Response.rightHost)
  return righthost_;
}
inline ::std::string* Response::release_righthost() {
  clear_has_righthost();
  if (righthost_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = righthost_;
    righthost_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response::set_allocated_righthost(::std::string* righthost) {
  if (righthost_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete righthost_;
  }
  if (righthost) {
    set_has_righthost();
    righthost_ = righthost;
  } else {
    clear_has_righthost();
    righthost_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.Response.rightHost)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::message::SubType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::SubType>() {
  return ::message::SubType_descriptor();
}
template <> struct is_proto_enum< ::message::DevType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::DevType>() {
  return ::message::DevType_descriptor();
}
template <> struct is_proto_enum< ::message::PushType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::PushType>() {
  return ::message::PushType_descriptor();
}
template <> struct is_proto_enum< ::message::RetCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::RetCode>() {
  return ::message::RetCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Message_2eproto__INCLUDED
